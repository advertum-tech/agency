import type { Metadata } from "next";
import Image from "next/image";

export const metadata: Metadata = {
  title:
    "Harness-инженерия: использование Codex в мире, где агенты — на первом месте",
  description:
    "Как команда OpenAI за пять месяцев построила продукт с нуля — миллион строк кода без единой строки, написанной вручную. Перевод Advertum.",
};

export default function HarnessEngineering() {
  return (
    <article className="bg-white text-main">
      <div className="mx-auto max-w-[680px] px-5 py-16 md:py-24">
        {/* Header */}
        <header className="mb-12 border-b border-gray-300 pb-10 text-center">
          <p className="mb-1 text-[10px] uppercase tracking-[3px] text-gray-400">
            11 февраля 2026
          </p>
          <p className="mb-8 text-[9px] uppercase tracking-[2px] text-gray-400">
            Инженерия
          </p>
          <h1 className="mb-3 font-serif text-4xl font-bold leading-tight tracking-tight text-gray-900 md:text-5xl">
            Harness-инженерия
          </h1>
          <p className="mb-6 font-serif text-lg italic text-gray-500 md:text-xl">
            Использование Codex в мире, где агенты — на первом месте
          </p>
          <p className="text-xs tracking-wide text-gray-400">
            Райан Лопополо, OpenAI · Перевод: Advertum
          </p>
        </header>

        {/* Lead */}
        <p className="mb-6 text-lg font-light leading-relaxed text-gray-700 md:text-xl">
          Последние пять месяцев наша команда ставила эксперимент: построить и
          запустить внутреннюю бету программного продукта с нулём строк кода,
          написанных вручную.
        </p>

        {/* Body */}
        <div className="article-body space-y-5 text-[15px] leading-[1.8] text-gray-700">
          <p>
            У продукта есть ежедневные внутренние пользователи и внешние
            альфа-тестеры. Он выкатывается, деплоится, ломается и чинится.
            Разница в том, что каждая строка кода — логика приложения, тесты, CI,
            документация, наблюдаемость, внутренний инструментарий — написана
            Codex. Мы оцениваем, что построили всё это примерно за 1/10 времени,
            которое заняло бы написание вручную.
          </p>

          <p className="py-4 text-center font-serif text-base italic leading-relaxed text-gray-500 md:px-8 md:text-lg">
            Люди направляют. Агенты исполняют.
          </p>

          <p>
            Мы намеренно выбрали это ограничение, чтобы построить всё
            необходимое для увеличения скорости разработки на порядки. У нас были
            недели, чтобы поставить то, что в итоге стало миллионом строк кода.
            Для этого нужно было понять, что меняется, когда главная задача
            инженерной команды — больше не писать код, а проектировать среды,
            формулировать намерения и создавать петли обратной связи, позволяющие
            агентам Codex выполнять надёжную работу.
          </p>

          <p>
            Этот пост — о том, чему мы научились, создавая совершенно новый
            продукт с командой агентов: что ломалось, что накапливалось, и как
            максимизировать наш единственный по-настоящему дефицитный ресурс —
            человеческое время и внимание.
          </p>

          {/* Section: Empty git repo */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Мы начали с пустого git-репозитория
          </h2>

          <p>
            Первый коммит в пустой репозиторий лёг в конце августа 2025 года.
          </p>

          <p>
            Первоначальный каркас — структура репозитория, CI-конфигурация,
            правила форматирования, настройка пакетного менеджера и
            фреймворк приложения — был сгенерирован Codex CLI с использованием
            GPT&#8209;5 на основе небольшого набора существующих шаблонов. Даже
            исходный файл AGENTS.md, указывающий агентам, как работать в
            репозитории, сам был написан Codex.
          </p>

          <p>
            Не было ни строчки написанного людьми кода, на которую можно было бы
            опереться. С самого начала репозиторий формировался агентом.
          </p>

          <p>
            Пять месяцев спустя репозиторий содержит порядка миллиона строк кода
            — логика приложения, инфраструктура, инструменты, документация и
            внутренние утилиты разработчика. За этот период примерно 1 500
            пулл-реквестов были открыты и влиты командой из всего трёх
            инженеров, управляющих Codex. Это даёт среднюю пропускную
            способность 3,5 PR на инженера в день, и, что удивительно,
            пропускная способность росла по мере расширения команды до
            нынешних семи инженеров. Важно: это не был выхлоп ради выхлопа —
            продуктом пользовались сотни людей внутри компании, включая
            ежедневных «опытных пользователей».
          </p>

          <p>
            На протяжении всего процесса разработки люди ни разу не написали код
            напрямую. Это стало ключевой философией команды:{" "}
            <strong className="font-semibold text-gray-900">
              никакого кода, написанного вручную
            </strong>
            .
          </p>

          {/* Section: Redefining role */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Переосмысление роли инженера
          </h2>

          <p>
            Отсутствие ручного кодирования породило иной тип инженерной работы,
            сосредоточенный на системах, каркасах и рычагах.
          </p>

          <p>
            Ранний прогресс шёл медленнее, чем мы ожидали — не потому, что Codex
            был неспособен, а потому, что среда была недоопределена. У агента не
            было инструментов, абстракций и внутренней структуры, необходимых для
            продвижения к высокоуровневым целям. Основной задачей нашей инженерной
            команды стало создание условий, позволяющих агентам делать полезную
            работу.
          </p>

          <p>
            На практике это означало работу в глубину: разбиение крупных целей на
            маленькие строительные блоки (дизайн, код, ревью, тесты и т.д.),
            задание агенту на создание этих блоков и использование их для
            разблокировки более сложных задач. Когда что-то ломалось, решением
            почти никогда не было «попробуй ещё раз». Поскольку единственный
            способ продвинуться — заставить Codex сделать работу, инженеры всегда
            подходили к задаче и спрашивали: «какой возможности не хватает и как
            сделать её одновременно читаемой и обязательной для агента?»
          </p>

          <p>
            Люди взаимодействуют с системой почти исключительно через промпты:
            инженер описывает задачу, запускает агента и позволяет ему открыть
            пулл-реквест. Чтобы довести PR до завершения, мы инструктируем Codex
            делать ревью собственных изменений локально, запрашивать дополнительные
            целевые агентские ревью и локально, и в облаке, реагировать на
            обратную связь от людей и агентов и итерировать в цикле, пока все
            агенты-ревьюеры не будут удовлетворены (фактически это{" "}
            <a
              href="https://ghuntley.com/loop/"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              Ralph Wiggum Loop
            </a>
            ). Codex использует наши стандартные инструменты разработки напрямую
            (gh, локальные скрипты, встроенные в репозиторий навыки) для сбора
            контекста — без копирования-вставки людьми в CLI.
          </p>

          <p>
            Люди могут ревьюить пулл-реквесты, но не обязаны. Со временем мы
            перенесли почти все усилия по ревью на взаимодействие агент-агент.
          </p>

          {/* Section: Legibility */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Повышение читаемости приложения
          </h2>

          <p>
            По мере роста пропускной способности по коду нашим узким местом стала
            способность людей к QA. Поскольку фиксированным ограничением было
            человеческое время и внимание, мы работали над тем, чтобы добавить
            агенту больше возможностей, делая сам UI приложения, логи и метрики
            непосредственно читаемыми для Codex.
          </p>

          <p>
            Например, мы сделали приложение загружаемым для каждого git worktree,
            чтобы Codex мог запускать и управлять отдельным экземпляром для каждого
            изменения. Мы также подключили Chrome DevTools Protocol к среде
            выполнения агента и создали навыки для работы со снимками DOM,
            скриншотами и навигацией. Это позволило Codex воспроизводить баги,
            валидировать исправления и рассуждать о поведении UI напрямую.
          </p>

          {/* Image: Codex drives the app */}
          <figure className="!my-8">
            <Image
              src="/images/blog/harness-engineering/fig-1-codex-drives-app.png"
              alt="Codex управляет приложением через Chrome DevTools Protocol для валидации своей работы"
              width={680}
              height={400}
              className="w-full rounded"
            />
            <figcaption className="mt-2 text-center text-xs text-gray-400">
              Codex управляет приложением через Chrome DevTools MCP для валидации
              своей работы
            </figcaption>
          </figure>

          <p>
            То же самое мы сделали для инструментов наблюдаемости. Логи, метрики и
            трейсы доступны Codex через локальный стек наблюдаемости, эфемерный для
            каждого worktree. Codex работает на полностью изолированной версии
            приложения — включая его логи и метрики, которые уничтожаются после
            завершения задачи. Агенты могут запрашивать логи через LogQL и метрики
            через PromQL. С таким контекстом промпты вроде «убедись, что запуск
            сервиса завершается менее чем за 800 мс» или «ни один span в этих
            четырёх критических пользовательских путях не превышает двух секунд»
            становятся выполнимыми.
          </p>

          {/* Image: Observability stack */}
          <figure className="!my-8">
            <img
              src="/images/blog/harness-engineering/observability-stack.svg"
              alt="Полный стек наблюдаемости для Codex"
              className="w-full rounded"
            />
            <figcaption className="mt-2 text-center text-xs text-gray-400">
              Полный стек наблюдаемости, доступный Codex
            </figcaption>
          </figure>

          <p>
            Мы регулярно наблюдаем, как одиночные запуски Codex работают над одной
            задачей более шести часов (часто пока люди спят).
          </p>

          {/* Section: Repository knowledge */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Мы сделали знание репозитория системой записи
          </h2>

          <p>
            Управление контекстом — одна из главных проблем в обеспечении
            эффективности агентов на больших и сложных задачах. Один из первых
            усвоенных уроков был простым: давайте Codex карту, а не инструкцию на
            1 000 страниц.
          </p>

          <p>
            Мы попробовали подход «один большой{" "}
            <a
              href="https://agents.md/"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              AGENTS.md
            </a>
            ». Он предсказуемо провалился:
          </p>

          <ul className="list-disc space-y-2 pl-6">
            <li>
              <strong className="font-semibold text-gray-900">
                Сложно верифицировать.
              </strong>{" "}
              Единый блоб не поддаётся механическим проверкам (покрытие,
              актуальность, владельцы, перекрёстные ссылки), поэтому дрейф
              неизбежен.
            </li>
            <li>
              <strong className="font-semibold text-gray-900">
                Мгновенно устаревает.
              </strong>{" "}
              Монолитный мануал превращается в кладбище устаревших правил. Агенты
              не могут определить, что всё ещё верно, люди перестают поддерживать
              его, и файл тихо становится привлекательной помехой.
            </li>
            <li>
              <strong className="font-semibold text-gray-900">
                Слишком много руководства — это отсутствие руководства.
              </strong>{" "}
              Когда всё «важно», ничто не важно. Агенты начинают паттерн-матчить
              локально вместо осознанной навигации.
            </li>
            <li>
              <strong className="font-semibold text-gray-900">
                Контекст — дефицитный ресурс.
              </strong>{" "}
              Гигантский файл инструкций вытесняет задачу, код и релевантную
              документацию — агент либо упускает ключевые ограничения, либо
              начинает оптимизировать не то.
            </li>
          </ul>

          <p>
            Поэтому вместо того чтобы трактовать <code>AGENTS.md</code> как
            энциклопедию, мы трактуем его как оглавление.
          </p>

          <p>
            База знаний репозитория живёт в структурированном каталоге{" "}
            <code>docs/</code>, который рассматривается как система записи.
            Короткий <code>AGENTS.md</code> (примерно 100 строк) вставляется в
            контекст и служит прежде всего картой, с указателями на более глубокие
            источники истины в других местах.
          </p>

          {/* Code block: directory structure */}
          <div className="!my-8 overflow-x-auto rounded bg-gray-50 p-4 font-mono text-[13px] leading-relaxed text-gray-700">
            <pre>{`AGENTS.md
ARCHITECTURE.md
docs/
├── design-docs/
│   ├── index.md
│   ├── core-beliefs.md
│   └── ...
├── exec-plans/
│   ├── active/
│   ├── completed/
│   └── tech-debt-tracker.md
├── generated/
│   └── db-schema.md
├── product-specs/
│   ├── index.md
│   ├── new-user-onboarding.md
│   └── ...
├── references/
│   ├── design-system-reference-llms.txt
│   ├── nixpacks-llms.txt
│   ├── uv-llms.txt
│   └── ...
├── DESIGN.md
├── FRONTEND.md
├── PLANS.md
├── PRODUCT_SENSE.md
├── QUALITY_SCORE.md
├── RELIABILITY.md
└── SECURITY.md`}</pre>
          </div>

          <p className="text-center text-xs italic text-gray-400">
            Структура хранилища знаний внутри репозитория.
          </p>

          {/* Image: Knowledge limits */}
          <figure className="!my-8">
            <Image
              src="/images/blog/harness-engineering/knowledge-limits.png"
              alt="Пределы знаний агента"
              width={680}
              height={400}
              className="w-full rounded"
            />
            <figcaption className="mt-2 text-center text-xs text-gray-400">
              Пределы знаний агента: что внутри репозитория — существует, что
              снаружи — нет
            </figcaption>
          </figure>

          <p>
            Проектная документация каталогизирована и проиндексирована, включая
            статус верификации и набор базовых убеждений, определяющих принципы
            работы «агент в первую очередь».{" "}
            <a
              href="https://matklad.github.io/2021/02/06/ARCHITECTURE.md.html"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              Архитектурная документация
            </a>{" "}
            предоставляет карту верхнего уровня по доменам и слоям пакетов.
            Документ по качеству оценивает каждый продуктовый домен и
            архитектурный слой, отслеживая пробелы во времени.
          </p>

          <p>
            Планы трактуются как полноценные артефакты. Для небольших изменений
            используются эфемерные облегчённые планы, а сложная работа
            фиксируется в{" "}
            <a
              href="https://cookbook.openai.com/articles/codex_exec_plans"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              планах исполнения
            </a>{" "}
            с журналами прогресса и решений, которые коммитятся в репозиторий.
            Активные планы, завершённые планы и известный техдолг — всё
            версионировано и расположено рядом, позволяя агентам работать без
            внешнего контекста.
          </p>

          <p>
            Это обеспечивает прогрессивное раскрытие: агенты начинают с небольшой,
            стабильной точки входа и знают, куда смотреть дальше, вместо того чтобы
            быть перегруженными с самого начала.
          </p>

          <p>
            Мы обеспечиваем это механически. Выделенные линтеры и CI-джобы
            проверяют, что база знаний актуальна, содержит перекрёстные ссылки и
            структурирована правильно. Повторяющийся агент «садовник документации»
            сканирует устаревшую или неактуальную документацию, не отражающую
            реальное поведение кода, и открывает корректирующие пулл-реквесты.
          </p>

          {/* Section: Agent legibility */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Читаемость для агента — цель
          </h2>

          <p>
            По мере развития кодовой базы фреймворк Codex для принятия проектных
            решений тоже должен был развиваться.
          </p>

          <p>
            Поскольку репозиторий целиком сгенерирован агентом, он в первую очередь
            оптимизирован под читаемость для Codex. Точно так же, как команды
            стремятся улучшить навигацию по коду для новых инженеров, целью наших
            инженеров было сделать так, чтобы агент мог рассуждать обо всём
            бизнес-домене непосредственно из самого репозитория.
          </p>

          <p>
            С точки зрения агента, всё, что он не может получить в контексте во
            время работы, фактически не существует. Знания, живущие в Google Docs,
            чатах или головах людей, недоступны системе. Локальные для репозитория
            версионированные артефакты (код, markdown, схемы, исполняемые планы) —
            это всё, что он может видеть.
          </p>

          <p>
            Мы усвоили, что нужно переносить всё больше контекста в репозиторий.
            Та дискуссия в Slack, которая выровняла команду по архитектурному
            паттерну? Если она не обнаруживаема для агента, она нечитаема — точно
            так же, как была бы неизвестна новому сотруднику, пришедшему три месяца
            спустя.
          </p>

          <p>
            Дать Codex больше контекста — значит организовать и выставить правильную
            информацию так, чтобы агент мог рассуждать над ней, а не перегружать
            его специальными инструкциями. Точно так же, как при онбординге нового
            коллеги по продуктовым принципам, инженерным нормам и командной
            культуре (включая предпочтения по эмодзи) — предоставление этой
            информации агенту приводит к более согласованному результату.
          </p>

          <p>
            Этот фрейм прояснил многие компромиссы. Мы отдавали предпочтение
            зависимостям и абстракциям, которые можно полностью интернализировать
            и обдумать внутри репозитория. Технологии, часто описываемые как
            «скучные», как правило, легче поддаются моделированию агентами
            благодаря композируемости, стабильности API и представленности в
            обучающей выборке. В некоторых случаях дешевле было поручить агенту
            реимплементировать подмножество функциональности, чем обходить
            непрозрачное поведение публичных библиотек. Например, вместо того чтобы
            подключать универсальный пакет в стиле <code>p-limit</code>, мы
            реализовали собственный хелпер map-with-concurrency: он тесно
            интегрирован с нашей инструментацией OpenTelemetry, имеет 100%
            покрытие тестами и ведёт себя именно так, как ожидает наш рантайм.
          </p>

          <p>
            Перенос всё большей части системы в форму, которую агент может
            инспектировать, валидировать и модифицировать напрямую, увеличивает
            рычаг — не только для Codex, но и для других агентов (например,{" "}
            <a
              href="https://openai.com/index/introducing-aardvark/"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              Aardvark
            </a>
            ), работающих в той же кодовой базе.
          </p>

          {/* Section: Architecture and taste */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Обеспечение архитектуры и вкуса
          </h2>

          <p>
            Одна документация не удерживает полностью сгенерированную агентами
            кодовую базу связной. Обеспечивая инварианты, а не микроменеджеря
            реализации, мы позволяем агентам поставлять быстро, не подрывая
            фундамент. Например, мы требуем от Codex{" "}
            <a
              href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              парсить формы данных на границе
            </a>
            , но не предписываем, как именно это происходит (модель, похоже, любит
            Zod, но мы не указывали конкретную библиотеку).
          </p>

          <p>
            Агенты наиболее эффективны в средах со{" "}
            <a
              href="https://bits.logic.inc/p/ai-is-forcing-us-to-write-good-code"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              строгими границами и предсказуемой структурой
            </a>
            , поэтому мы построили приложение вокруг жёсткой архитектурной модели.
            Каждый бизнес-домен разделён на фиксированный набор слоёв, со строго
            валидированными направлениями зависимостей и ограниченным набором
            допустимых рёбер. Эти ограничения обеспечиваются механически через
            кастомные линтеры (сгенерированные Codex, разумеется!) и структурные
            тесты.
          </p>

          <p>
            Диаграмма ниже показывает правило: внутри каждого бизнес-домена
            (например, App Settings) код может зависеть только «вперёд» через
            фиксированный набор слоёв (Types → Config → Repo → Service → Runtime
            → UI). Сквозные аспекты (авторизация, коннекторы, телеметрия,
            фича-флаги) входят через единый явный интерфейс: Providers. Всё
            остальное запрещено и обеспечивается механически.
          </p>

          {/* Image: Architecture layers */}
          <figure className="!my-8">
            <Image
              src="/images/blog/harness-engineering/architecture-layers.png"
              alt="Слоистая доменная архитектура с явными сквозными границами"
              width={680}
              height={400}
              className="w-full rounded"
            />
            <figcaption className="mt-2 text-center text-xs text-gray-400">
              Слоистая доменная архитектура с явными сквозными границами
            </figcaption>
          </figure>

          <p>
            Это та архитектура, которую обычно откладывают, пока не наберётся сотня
            инженеров. С кодирующими агентами это ранняя необходимость: ограничения
            — то, что позволяет скорость без деградации или архитектурного дрейфа.
          </p>

          <p>
            На практике мы обеспечиваем эти правила кастомными линтерами и
            структурными тестами, плюс небольшой набор «инвариантов вкуса».
            Например, мы статически обеспечиваем структурированное логирование,
            соглашения об именовании для схем и типов, лимиты размера файлов и
            платформо-специфичные требования к надёжности через кастомные линты.
            Поскольку линты кастомные, мы пишем сообщения об ошибках так, чтобы
            внедрять инструкции по исправлению в контекст агента.
          </p>

          <p>
            В человеко-ориентированном рабочем процессе эти правила могут
            ощущаться педантичными или ограничивающими. С агентами они становятся
            множителями: однажды закодированные, они применяются повсюду и сразу.
          </p>

          <p>
            В то же время мы явно говорим, где ограничения важны, а где нет. Это
            напоминает управление крупной инженерной платформенной организацией:
            обеспечивай границы централизованно, допускай автономию локально. Вы
            глубоко заботитесь о границах, корректности и воспроизводимости. Внутри
            этих границ вы предоставляете командам — или агентам — значительную
            свободу в том, как выражаются решения.
          </p>

          <p>
            Результирующий код не всегда соответствует стилистическим предпочтениям
            людей, и это нормально. Пока результат корректен, поддерживаем и
            читаем для будущих запусков агента, он соответствует планке.
          </p>

          <p>
            Человеческий вкус непрерывно подаётся обратно в систему. Комментарии к
            ревью, рефакторинговые пулл-реквесты и пользовательские баги
            фиксируются как обновления документации или кодируются непосредственно
            в инструментарии. Когда документации не хватает, мы повышаем правило
            до кода.
          </p>

          {/* Section: Merge philosophy */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Пропускная способность меняет философию мержа
          </h2>

          <p>
            По мере роста пропускной способности Codex многие конвенциональные
            инженерные нормы стали контрпродуктивными.
          </p>

          <p>
            Репозиторий работает с минимумом блокирующих мерж-гейтов.
            Пулл-реквесты короткоживущие. Флейки в тестах часто решаются
            повторными запусками, а не бесконечной блокировкой прогресса. В
            системе, где пропускная способность агентов намного превышает
            человеческое внимание, коррекции дёшевы, а ожидание дорого.
          </p>

          <p>
            В среде с низкой пропускной способностью это было бы безответственно.
            Здесь это часто правильный компромисс.
          </p>

          {/* Section: What agent-generated means */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Что на самом деле значит «сгенерировано агентом»
          </h2>

          <p>
            Когда мы говорим, что кодовая база сгенерирована агентами Codex, мы
            имеем в виду{" "}
            <strong className="font-semibold text-gray-900">
              всё в кодовой базе
            </strong>
            .
          </p>

          <p>Агенты производят:</p>

          <ul className="list-disc space-y-1 pl-6">
            <li>Файлы определения продакшн-дашбордов</li>
            <li>Скрипты управления самим репозиторием</li>
            <li>Комментарии к ревью и ответы на них</li>
            <li>Оценочные харнессы</li>
            <li>Документацию и историю дизайна</li>
            <li>Внутренние инструменты разработчика</li>
            <li>CI-конфигурацию и инструменты релиза</li>
            <li>Продуктовый код и тесты</li>
          </ul>

          <p>
            Люди всегда остаются в петле, но работают на другом уровне абстракции.
            Мы приоритизируем работу, переводим пользовательскую обратную связь в
            критерии приёмки и валидируем результаты. Когда агент испытывает
            трудности, мы трактуем это как сигнал: определяем, чего не хватает —
            инструментов, ограждений, документации — и подаём это обратно в
            репозиторий, всегда поручая написание исправления самому Codex.
          </p>

          <p>
            Агенты используют наши стандартные инструменты разработки напрямую. Они
            забирают обратную связь с ревью, отвечают инлайн, пушат обновления и
            часто сами сквошат и мержат свои пулл-реквесты.
          </p>

          {/* Section: Increasing autonomy */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Растущие уровни автономии
          </h2>

          <p>
            По мере того как всё больше элементов цикла разработки кодировалось
            непосредственно в системе — тестирование, валидация, ревью, обработка
            обратной связи и восстановление — репозиторий недавно пересёк значимый
            порог, на котором Codex может end-to-end вести новую фичу.
          </p>

          <p>По одному промпту агент теперь может:</p>

          <ul className="list-disc space-y-1 pl-6">
            <li>Валидировать текущее состояние кодовой базы</li>
            <li>Воспроизвести сообщённый баг</li>
            <li>Записать видео, демонстрирующее сбой</li>
            <li>Реализовать исправление</li>
            <li>Валидировать исправление, управляя приложением</li>
            <li>Записать второе видео, демонстрирующее решение</li>
            <li>Открыть пулл-реквест</li>
            <li>Реагировать на обратную связь от агентов и людей</li>
            <li>Обнаружить и устранить сбои сборки</li>
            <li>Эскалировать человеку только когда требуется суждение</li>
            <li>Вмержить изменение</li>
          </ul>

          <p>
            Такое поведение сильно зависит от конкретной структуры и инструментария
            этого репозитория и не должно считаться обобщаемым без аналогичных
            инвестиций — по крайней мере, пока.
          </p>

          {/* Section: Entropy */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Энтропия и сборка мусора
          </h2>

          <p>
            Полная автономия агентов также порождает новые проблемы. Codex
            реплицирует паттерны, уже существующие в репозитории — даже неровные
            или субоптимальные. Со временем это неизбежно ведёт к дрейфу.
          </p>

          <p>
            Сначала люди решали это вручную. Наша команда тратила каждую пятницу
            (20% недели) на вычищение «ИИ-шлака». Неудивительно, что это не
            масштабировалось.
          </p>

          <p>
            Вместо этого мы начали кодировать то, что называем «золотыми
            принципами», непосредственно в репозитории и выстроили регулярный
            процесс очистки. Эти принципы — мнительные механические правила,
            которые поддерживают кодовую базу читаемой и консистентной для будущих
            запусков агента. Например: (1) мы предпочитаем общие утилитные пакеты
            вместо самописных хелперов, чтобы инварианты были централизованы, и
            (2) мы не прощупываем данные в стиле «YOLO» — мы валидируем границы
            или полагаемся на типизированные SDK, чтобы агент не мог случайно
            строить на угаданных формах. На регулярной каденции набор фоновых задач
            Codex сканирует отклонения, обновляет оценки качества и открывает
            целевые рефакторинговые пулл-реквесты. Большинство из них можно
            проревьюить менее чем за минуту и автомержить.
          </p>

          <p>
            Это работает как сборка мусора. Технический долг — как высокопроцентный
            кредит: почти всегда лучше гасить его непрерывно малыми порциями, чем
            копить и разбираться мучительными рывками. Человеческий вкус
            фиксируется один раз, а затем непрерывно обеспечивается на каждой
            строке кода. Это также позволяет ловить и устранять плохие паттерны
            ежедневно, а не позволять им распространяться по кодовой базе дни или
            недели.
          </p>

          {/* Section: Still learning */}
          <h2 className="!mt-10 !mb-5 font-serif text-2xl font-bold leading-tight text-gray-900 md:text-3xl">
            Чему мы всё ещё учимся
          </h2>

          <p>
            Эта стратегия пока хорошо работала вплоть до внутреннего запуска и
            принятия в OpenAI. Создание реального продукта для реальных
            пользователей помогло закрепить наши инвестиции в реальности и
            направить нас к долгосрочной поддерживаемости.
          </p>

          <p>
            Чего мы ещё не знаем — как архитектурная связность эволюционирует на
            протяжении лет в полностью агентно-сгенерированной системе. Мы всё ещё
            учимся, где человеческое суждение даёт наибольший рычаг и как
            кодировать это суждение так, чтобы оно накапливалось. Мы также не
            знаем, как эта система будет эволюционировать по мере того, как модели
            продолжат становиться более способными.
          </p>

          <p>
            Что стало ясно: создание ПО по-прежнему требует дисциплины, но теперь
            дисциплина проявляется больше в каркасах, чем в коде. Инструментарий,
            абстракции и петли обратной связи, поддерживающие связность кодовой
            базы, становятся всё более важными.
          </p>

          <p>
            Наши самые сложные задачи сейчас — проектирование сред, петель обратной
            связи и систем контроля, которые помогают агентам достигать нашей
            цели: строить и поддерживать сложное, надёжное программное обеспечение
            в масштабе.
          </p>

          <p>
            По мере того как агенты вроде Codex берут на себя всё большую часть
            жизненного цикла ПО, эти вопросы будут иметь ещё большее значение. Мы
            надеемся, что, поделившись некоторыми ранними уроками, поможем вам
            решить, куда инвестировать свои усилия, чтобы{" "}
            <a
              href="https://openai.com/codex/"
              className="underline decoration-gray-300 underline-offset-2 transition-colors hover:decoration-gray-900"
              target="_blank"
              rel="noopener noreferrer"
            >
              вы могли просто строить
            </a>
            .
          </p>
        </div>

        {/* Acknowledgements */}
        <div className="mt-12 border-t border-gray-300 pt-8 text-center font-serif text-sm italic leading-relaxed text-gray-500 md:text-base">
          <p>
            Особая благодарность Виктору Чжу и Заку Броку, внёсшим вклад в этот
            пост, а также всей команде, создавшей этот продукт.
          </p>
        </div>

        {/* Footer */}
        <p className="mt-14 text-center text-[9px] uppercase tracking-[1px] text-gray-400">
          Райан Лопополо, OpenAI · Перевод: Advertum · Февраль 2026
        </p>
      </div>
    </article>
  );
}
